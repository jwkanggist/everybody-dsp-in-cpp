//
//  JacobiSvd.h
//
//  Created by jwkangmacpro on 2018. 2. 2..
//  Copyright © 2018년 jwkangmacpro. All rights reserved.
//

#ifndef JacobiSvd_h
#define JacobiSvd_h


//#include "log.h"
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include "EverybodyMathLib.h"

# ifdef __DSPLIBTEST__
#include <fstream>
#include <iostream>
#endif

/*
This class tries to solve svd problem given a certain matrix A, given as
 
    [U,S,V] = svd(A);
 
 where the relation among the matrices is A = USV^T, each of matrix defined as:
    
    S: singular value matrix m by n, which is off-diagonalm including rank(A) number of singular values in S
    U: singluar vector matrix m by m generated by column space of A , which is orthonomal.
    V: singular vector matrix n by n generated by row space of A, which is orthonomal.
 
 written by Jaewook Kang @ 180202
 
 */

class JacobiSVD
{
public:
    JacobiSVD();
    JacobiSVD(const Matrix& mat_in, const bool matrixExportOptOn);
    JacobiSVD(const int colsize, const int rowsize, double** Adata, const bool matrixExportOptOn);
    ~JacobiSVD();
    
    
    void reset(const Matrix& Ain, const bool matrixExportOptOn);
    void reset(const int colsize, const int rowsize, double** Adata, const bool matrixExportOptOn);

    bool compute(const bool qropt);

    unsigned int getColSizeOfA() const {return mColSize_A;}
    unsigned int getRowSizeOfA() const {return mRowSize_A;}
    float        getNuclearNorm() const { return mNuclearNorm;}
    float        getSVDComputeTime() const { return mSVDCompute_ms;}

    //float        getRankOfA()   const { return mRankA;}
    
    Matrix&      getMatrixA()   {return mA;}
    Vector&      getSingularValues()
    {
        if (!mIsSvdRun)
        {
            printf("[JacobiSVD] singular values are not calculated.");
        }

        return mSingularValues;
    }
    
    Matrix&      getMatrixU()
    {
        if (!mIsSvdRun || !mIsSingularVectorMatrixExport)
        {
            printf("[JacobiSVD] Matrix U is not calculated.");
        }
        return mU;
    }
    
    Matrix&      getMatrixS()
    {
        if (!mIsSvdRun || !mIsSingularVectorMatrixExport)
        {
            printf("[JacobiSVD] Matrix S is not calculated.");
        }
        return mS;
    }
    
    Matrix&      getMatrixV()
    {
        if (!mIsSvdRun || !mIsSingularVectorMatrixExport)
        {
            printf("[JacobiSVD] Matrix V is not calculated.");
        }
        return mV;
    }
    
# ifdef __DSPLIBTEST__
    void showMatrixA();
    void showMatrixS();
    void showMatrixU();
    void showMatrixV();
    void showSingularValues();
    void showResult();
#endif

    
private:
    
    Matrix mA;
    Matrix mU, mS, mV;
    
    unsigned int mColSize_A;
    unsigned int mRowSize_A;
    unsigned int mNumOfSingularValues;
    //unsigned int mRankA;
    
    bool         mIsSingularVectorMatrixExport =  false;
    bool         mIsSvdRun = false;
    
    Vector mSingularValues;
    float mNuclearNorm;
    float  mSVDCompute_ms;
    

    void setMatrixA(const Matrix& Ain);
    void setMatrixA(const int colsize, const int rowsize, double** data);
};


#endif /* JacobiSvd_h */
